h1. Текущее положение (in-group)

Sender (использование ресивера):
* оптимизации (перевести на piggyback)
  - посылка total order при отправке скоординатора группы
  - посылка ack'ов при отправке с ресивера
  
Sender (зависимость от группы):
* failure detection только узлов группы
  - при сбое чиститься массив узлов, от которых ожидаются аки
  - детектор сбоев используется для фильтрации узлов группы, кому слать сообщения и комплешены
* участие во флаш протоколе
  - отсечка текущего и следующего членств при старте флаш, посылка бандла до старта флаш
  - посылка комплешина после старта флаш
  - блокировка флаш до завершения всех мультикастов текущего членства
  - отсечка мультикастов, требующих аков перед фазой процессинга
  - установка признака формирования группы по завершению флаш
  - отсылка сообщений, посланных до формирования группы по завершению флаш
* возможность посылки только после формирования группы (groupFormed), накопление сообщений до формирования группы и отправка их после завершения первого флаша
* состав узлов, требующих аков, соответсвует составу группы
* membership группы используется для 
  - детектирования ид группы
  - состава узлов для посылки сообщений и комплешенов

Sender (темы - текущее положение):
* детектирование сбоев узлов группы
  (listener и детектор сбоев кластера, а не группы)
* использование членства группы для посылки
* участие во флаш протоколе группы
* оптимизации (делаем через piggyback после всего остального)

h1. Out-group support

*ClusterMembership*:
* каждая группа в членстве кластера имеет свой идентификатор, монотонно изменяющийся при любом ее изменении в составе членства кластера
* членство группы на воркере формируется из членства группы кластера с копированием идентификатора членства(а не генерации нового). Проверить, что генерация монотонная и без пропусков

*In-group sender*:
* делаем сендер, который работает как сейчас, ресивер для которого работает как сейчас
* работает в подстеке группы
* нужен для посылок total ордеров и in-group посылок

*Out-group sender*:
* связан с конкретной группой и имеет текущее членство группы, обновляемое при обновлении текущего членства кластера
* ведет очередь отправки, которая разделена на отрезки одинакового членства, в котором были посланы сообщения этого отрезка
* каждый отрезок имеет список узлов, от которых нужно ожидать ack'и для сообщений отрезка, с каждым узлом связан идентификатор последнего принятого узлом сообщения. При обновлении членства из них удаляются выбывшие из кластера узлы
  - Вопрос: можно ли обойтись единым списком на все отрезки, с последующим удалением устаревших по таймеру, но нужно уметь определять конец мультикаста определенного отрезка (продумать). Может и не стоит этого делать, смена членства не такая частая
* новые сообщения шлются в текущем членстве, ресивер при нормальном ходе вещей может ответить ack'ом с указанием ид последнего принятого сообщения, которое будет записано как последний принятый для заданного ресивера. При флаш ресивер может ответить удалением отрезка заданного членства и более старых, т.к. все их сообщения приняты (сендер при этом вызывает для них деливери хэндлер и удаляет заданные отрезки). При посылке в устаревшем членстве ресивер может отклонить прием с указанием того, что членство устарело и указанием текущего членства. При этом сендер должен дождаться инсталляции как минимум заданного членства или более поздних и в них перепослать заданные сообщения заново
* оптимизации (перевести на piggyback)
  - посылка total order при отправке скоординатора группы
  - посылка ack'ов при отправке с ресивера
  - Вопрос: насколько они нужны?

*Receiver*:
* маркирует каждую очередь приема как in-group или out-group, в зависимости от сендера сообщения
* для in-group посылок работает как сейчас
* имеет общую на весь узел pending queue для приема сообщений когда группа еще не инсталлирована на узле
  - обработка очереди идет обычным приемом ее сообщений в заданной группе после ее инсталяции на узел
  - сообщения попадают в очередь только, если их членство ранее не было инсталлировано на узел (иначе группа могла быть удалена с узла как часть миграции данных)
* имеет pending queue на каждую out-group receive queue для приема сообщений, посланных в более новом членстве
  - обработка очереди идет в момент завершения флаш обычным приемом тех сообщений, идентификатор членства которых совпадает с текущим членством группы
* Прием out-group сообщений
  - при получении сообщения в новом членстве, которое не было инсталлировано ранее, и группа еще не создана, добавить сообщение в pending queue узла
  - если сообщение было послано в новом членстве - добавить в pending queue очереди приема для данного сендера
  - при приеме сообщения в том же членстве, принять, послать аки, принять комплиты и сделиверить обычным образом
  - при получении на одних узлах в текущем членстве (как минимум на одном), а на других на единицу большем (как минимум без таких узлов) при работающем флаш на этих узлах стабилизировать сообщения сендера и по завершении флаш послать уведомление об удалении отрезка предыдущего членства (с вызовом delivery handler)
    * Вопрос: от кого слать такой ответ, от всех ресиверов или только координатора
      - шлется сообщение о необходимости выполнить флаш с того узла, который детектировал эту необходимость (если падает координатор или один из узлов группы флаш начнется автоматически и стабилизирует все,пожтому посылка уведомлений о флаш не требует доп. гарантий)
  - при посылке сообщения в старом членстве уведомить сендера о перепосылке и игнорировать прием
    * Вопрос: При получении сообщения ресивером с членством на единицу большим чем у сообщения при работающем флаш будет выдано уведомление о перепосылке, хотя есть и те кто принял в правильном членстве и сообщение может быть стабилизировано
    * Вопрос: при рассылке членства может сложиться такая ситуация, когда ресиверы группы получат новое членство и начнут инсталлировать флаш, а потенциальные сендеры получат членство позже, им придется перепосылать часть сообщений. Нужно либо задерживать инсталляцию на ресиверах на немного, либо разрешить прием сообщений предыдущего членства в фазе стабилизации
* на флаш или при падении любого сендера, для которого есть receive queue, начать флаш и завершить его мультикасты, уведомить всех работоспособных out-group сендеров о завершении мультикаста для заданных отрезков очереди отправки, соответсвующих членству, предыдущему к флаш
  - Вопрос: out-group сендер не является частью группы, поэтому флаш будет инициирован не от смены кластера, как быть с идентификатором членства группы (может подлерживать два идентификатора - группы в кластере и флаша)
  - Вопрос: кто должен инициировать флаш при падении сендера - координатор или каждый ресивер
  - Вопрос: нужно ли перезапускать фазу стабилизации флаш, если в этой фазе упал один из out-group сендеров. Перезапуск может потребоваться для блокировки сообщений от заданного сендера (особенно это касается сообщений, порождающих total order) и перевычислении ретрансмитов. Возможно для out-group это менеее актуально

*Out-group Sender Protocol stack*
* WorkerGroupMembershipProtocol
  - держим мапку мультикаст сендеров по ключу ид группы
  - все посылки (простые и pullable) идут через нее
  - сендер добавляется в мапу по требованию при первой посылке, если его группа есть в членстве кластера
  - сендер удаляется из мапы в момент изменения членства кластера, если его группа была удалена из членства.
    * Вопрос: Возможно сендер также удаляется при простое, но тогда при простое нужно удалять из очереди приема, например для узлов, которые пишут во множество групп недетерменированным образом
  
*Возможные оптимизации*:
* посылка аков через piggyback вместе смультикаст сообщениями. Но проверка возможности посылки ака должна идти не по каждому сообщению, проходящему через стек, а возможно только по мультикаст сообщениям
* аналогично посылка total order с координатора группы
* автоматическая синхронизация членства сендера, если его узел является членом группы (ресивер при отработке флаш протокола пытается найти сендера этой групаы на локальном узле и изменить его текущее членство группы