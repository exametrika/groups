h1. Текущее положение (in-group)

Sender (использование ресивера):
* оптимизации (перевести на piggyback)
  - посылка total order при отправке скоординатора группы
  - посылка ack'ов при отправке с ресивера
  
Sender (зависимость от группы):
* failure detection только узлов группы
  - при сбое чиститься массив узлов, от которых ожидаются аки
  - детектор сбоев используется для фильтрации узлов группы, кому слать сообщения и комплешены
* участие во флаш протоколе
  - отсечка текущего и следующего членств при старте флаш, посылка бандла до старта флаш
  - посылка комплешина после старта флаш
  - блокировка флаш до завершения всех мультикастов текущего членства
  - отсечка мультикастов, требующих аков перед фазой процессинга
  - установка признака формирования группы по завершению флаш
  - отсылка сообщений, посланных до формирования группы по завершению флаш
* возможность посылки только после формирования группы (groupFormed), накопление сообщений до формирования группы и отправка их после завершения первого флаша
* состав узлов, требующих аков, соответсвует составу группы
* membership группы используется для 
  - детектирования ид группы
  - состава узлов для посылки сообщений и комплешенов

Sender (темы - текущее положение):
* детектирование сбоев узлов группы
  (listener и детектор сбоев кластера, а не группы)
* использование членства группы для посылки
* участие во флаш протоколе группы
* оптимизации (делаем через piggyback после всего остального)

h1. Out-group support

-*ClusterMembership*-:
* каждая группа в членстве кластера имеет свой идентификатор, монотонно изменяющийся при любом ее изменении в составе членства кластера
* членство группы на воркере формируется из членства группы кластера с копированием идентификатора членства(а не генерации нового). Проверить, что генерация монотонная и без пропусков
* флаш идентификатор членства группы при этом формируется независимо, т.к. флаш может быть вызван не только изменениями членства - например, при падении out-group сендера
* присинхронизации членств между ресивером и сендером используется именно идентификатор членства группы викластере, не флаш идентификатор членства группы

-*In-group sender*-:
* делаем сендер, который работает как сейчас, ресивер для которого работает как сейчас
* работает в подстеке группы
* нужен для посылок total ордеров и in-group посылок

*Out-group sender*:
* связан с конкретной группой и имеет текущее членство группы, обновляемое при обновлении текущего членства кластера
* ведет очередь отправки, которая разделена на отрезки одинакового членства, в котором были посланы сообщения этого отрезка
* каждый отрезок имеет список узлов, от которых нужно ожидать ack'и для сообщений отрезка, с каждым узлом связан идентификатор последнего принятого узлом сообщения. При обновлении членства из них удаляются выбывшие из кластера узлы
  - Вопрос: можно ли обойтись единым списком на все отрезки, с последующим удалением устаревших по таймеру, но нужно уметь определять конец мультикаста определенного отрезка (продумать). Может и не стоит этого делать, смена членства не такая частая
    * Решение: имеем общую мапку узлов, с ключом ид узла и значением счетчика последнего принятого сообщения этого узла, на каждом отрезке имеем список указателей на элемент мапки (пару ключ:значение).
    При получении ака обновляем счетчик последнего принятого, при формировании комплита проходим по списку и считаем минимальный принятый. При удалении отрезка, удаляем список. Последний отрезок всегда текущий и не удаляется, отражает текущее членство. Если элемент мапки не испольщуется ни в каком отрезке, удаляем его (он устарел), удаление может быть по счетчику (при его обнулении). При инсталляции нового членства группы кластера, удаляем измапки и всех списков отрезков выбывшие из кластера узлы, нет смысла ждать от них аков
* новые сообщения шлются в текущем членстве, ресивер при нормальном ходе вещей может ответить ack'ом с указанием ид последнего принятого сообщения, которое будет записано как последний принятый для заданного ресивера. При флаш ресивер может ответить удалением отрезка заданного членства и более старых, т.к. все их сообщения приняты (сендер при этом вызывает для них деливери хэндлер и удаляет заданные отрезки). При посылке в устаревшем членстве ресивер может отклонить прием с указанием того, что членство устарело и указанием текущего членства. При этом сендер должен дождаться инсталляции как минимум заданного членства или более поздних и в них перепослать заданные сообщения заново
* оптимизации (перевести на piggyback)
  - посылка total order при отправке скоординатора группы
    - реализуется in-group sender'ом, не требует реализации out-group'а
  - посылка ack'ов при отправке с ресивера
    - возможно имеет смысл реализовать через пиггибэк, но важно чтобы использовались только мультикасты для переноса и никакие другие, чтобы оверхед был минимален
* при получении реджекта нужно по каждому отрезку, членство которого меньше присланного в реджекте сбросить членство и списки аков. Если текущее членство сендера меньше присланного, дождаться установки требуемого и заполнить в этих отрезках членство и списки аков, после чего перепослать их в новом членстве
  - Вопрос: возможена ситуация, когда более старые сообщения посылаются в старом членстве, а более новые в новом, при этом старые реджектятся, а новые нет и нарушается фифо порядок приема сообщений
    * варианты: реджектить более новые с последующей пересылкой, принимать сообщения но блокировать получение total order'а до момента получения более новых
    * текущая реализация все это уже подлерживает, не требуется никаких действий

*Receiver*:
* при проверке членствавсегда используется prepared членство группы иид членства группы в кластере (не ид членства флаш)
* всегдасравниваются два членства, в котором было послано сообщение и которое является текущим для данного ресивера приполучении сообщения, наличие флаш всегда относится к ресиверу, был или нет флаш в момент получения сообщения
* маркирует каждую очередь приема как in-group или out-group, в зависимости от сендера сообщения
* для in-group посылок работает как сейчас
* имеет общую на весь узел pending queue для приема сообщений когда группа еще не инсталлирована на узле
  - обработка очереди идет обычным приемом ее сообщений в заданной группе после ее инсталяции на узел
  - сообщения попадают в очередь только, если их членство ранее не было инсталлировано на узел (иначе группа могла быть удалена с узла как часть миграции данных)
* имеет pending queue на каждую out-group receive queue для приема сообщений, посланных в более новом членстве
  - обработка очереди идет в момент завершения флаш обычным приемом тех сообщений, идентификатор членства которых совпадает с текущим членством группы
* Прием out-group сообщений
  - при получении сообщения в новом членстве, которое не было инсталлировано ранее, и группа еще не создана, добавить сообщение в pending queue узла
  - если сообщение было послано в новом членстве, либо в текущем членстве при работающем флаш - добавить в pending queue очереди приема для данного сендера до момента завершения инсталляции членства сообщения
  - при приеме сообщения в том же членстве вне флаш, принять, послать аки, принять комплиты и сделиверить обычным образом
  - при получении на одних узлах в текущем членстве (как минимум на одном) вне флаш, а на других на единицу большем (как минимум без таких узлов) при работающем флаш на этих узлах стабилизировать сообщения сендера и по завершении флаш послать уведомление об удалении отрезка предыдущего членства (с вызовом delivery handler)
    * Вопрос: от кого слать такой ответ, от всех ресиверов или только координатора
      - по завершению флаш текущий координатор шлет уведомление всем работоспособным out-group сендерам. При любых падениях будет сформирован новый флаш сновым координатором и возможно новым членством группы, и он перепошлет уведомление об удалении в любом случае, просто возможно с некоторой задержкой
  - при посылке сообщения в старом членстве уведомить сендера о перепосылке и игнорировать прием
    * Вопрос: При получении сообщения ресивером с членством на единицу большим чем у сообщения при работающем флаш будет выдано уведомление о перепосылке, хотя есть и те кто принял в правильном членстве и сообщение может быть стабилизировано
      - можно реджектить по тихому такое сообщение, но запомнить ид сообщения и по завершении фазы стабилизации если сообщение не было сьтабилизировано и принято, а зареджектено всеми, посылать уведомление сендеро о реджекте, иначе ничего не слать
    * Вопрос: при рассылке членства может сложиться такая ситуация, когда ресиверы группы получат новое членство и начнут инсталлировать флаш, а потенциальные сендеры получат членство позже, им придется перепосылать часть сообщений. 
      - Нужно на ресиверах задержать инсталляцию и старт флаш после приема членства кластера на немного, чтобы сендеры гарантировано инсталлировали новое членство и кол-во перепосылок было минимальным
* на флаш или при падении любого сендера, для которого есть receive queue, начать флаш и завершить его мультикасты, уведомить всех работоспособных out-group сендеров о завершении мультикаста для заданных отрезков очереди отправки, соответсвующих членству, предыдущему к флаш
  - Вопрос: out-group сендер не является частью группы, поэтому флаш будет инициирован не от смены кластера, как быть с идентификатором членства группы 
    * нужно подлерживать два идентификатора - группы в кластере и флаша
  - Вопрос: кто должен инициировать флаш при падении сендера - координатор или каждый ресивер
    * шлется сообщение о необходимости выполнить флаш с того узла, который детектировал эту необходимость (если падает координатор или один из узлов группы флаш начнется автоматически и стабилизирует все, поэтому посылка уведомлений о флаш не требует доп. гарантий)
  - Вопрос: нужно ли перезапускать фазу стабилизации флаш, если в этой фазе упал один из out-group сендеров. Перезапуск может потребоваться для блокировки сообщений от заданного сендера (особенно это касается сообщений, порождающих total order) и перевычислении ретрансмитов.
    - гаверное не нужно, т.к. сендер все равно всегдапишет в произвольном членстве, поэтому упал сендер или нет с точки зрения флаша не должно иметь разницы
* Вопрос: при флаше ресивер сейчас не ждет перепосылок сендера, если будут дырки при неупавшем сендера флаш не сможет доставить сообщения и завершиться, как быть вдесь
  - ресиверы, детектировавшие пропуски в сообщениях сендера, если сендер не упал, блокируют флаш до момента заполнения пропусков

*Out-group Sender Protocol stack*
* WorkerGroupMembershipProtocol
  - держим мапку мультикаст сендеров по ключу ид группы
  - все посылки (простые и pullable) идут через нее
  - сендер добавляется в мапу по требованию при первой посылке, если его группа есть в членстве кластера
  - сендер удаляется из мапы в момент изменения членства кластера, если группа была удалена из членства.
    * Вопрос: Возможно сендер также удаляется при простое, но тогда при простое нужно удалять из очереди приема, например для узлов, которые пишут во множество групп недетерменированным образом
      - очереди приема на текущий момент удаляются при выбытии узла из группы перед фазой процессинга и при простое по таймеру. Аналогично в новом варианте для out-group очередей приема они должны удаляться при выходе сендеров из кластера или при простое, out-group сендер должен удаляться при удалении группы или при простое, но только, если все мультикасты завершены
    * Вопрос: возможна при этом ситуация, когда при удалении группы часть муоьтикастов была не отправлена, они будут потеряны, но уведомление о доставки через деливери хэндлер не будет направлено и отправитель модет их перенаправить в новую группу (если нужно)
      - если требуется не терять сообщения при удалении группы, нужно флашить их отдельным раундом (протоколом более верзнего уровня) с одновременной блокировкой посылки - это уже миграция шардов. Пока не делаем