* переделать StateStransferMessageLog в объектно-ориентированный с состоянием RandomAccessFile, позволяет дописать в файл или позиционироваться в начало и прочитать пачками по несколько сообщений в порядке записи. Также имеет операцию close (наследуется от Closeable). Использовать его (однократно) при записи/чтении сообщения передачи состояния, и многократно при сохранении/чтении pending сообщений при записи снимка
* в случае больших снимков в StateTransferServerProtocol вместо ограничения по flowControl лучше сделать запись pending сообщений в файл с последующим проигрыванием их, если их количество превысило заданный порог. Просто накапливаем сообщения и если суммарный размер сообщений больше заданного, аппендим в MessagesLog и чистим массив pendingMessages. Перед проигрыванием дописываем хвост сообщений в конец файла, очищаем массив, позиционируемся на начало файла и проигрываем пачками заданного размера. FlowControl убираем

* Сделать StateTransfer Тесты
* проверить групповые протоколы на потокобезопасность при stop/start. Можно сделать закрытие channel через compartment, чтобы не требовалась синхронизация. По аналогии с gracefull вызывается stop в контексте compartment, проверка на stopped и присваивание stopped = true выполняется до вызова и под синхронизатором, остальные без синхронизации
* LocalSendOptimizationProtocol introduces delays in handling local messages, it is necessary to implement process method in ICompartmentProcessor which is called on each dispatch iteration and move message handling logics into it. How to do it performantly, so only exactly this only protocol gets called, not others
* make GracefullCloseStrategy two phase - request and close phase to consistently close protocols or better make close protocol mechanics based on protocol stop (now some protocols use stop, some - GracefullCloseStrategy, we need single approach)
* прогнать все тесты группы, чтобы работали
* DataExchangeProtocol - сделать простой обмен координатор-группа
* FailureAtomicProtocol - учесть, что StateTransfer Должен быть выше по стеку чем данный протокол
--------------
Groups Core:
* сделать тесты groups
  - настроить базовые параметры канала (таймауты и др.) в более короткие интервалы
  - core discovery - протестировать 
    * доделать multicast, azure/aws discovery
  - core failure detection (heartbeat, tcp + node tracking strategies) - сделать тесты
  - core dynamic membership + flush - сделать тесты
  - core state transfer + data exchange - сделать тесты
* atomic multicast
* канал + фабрика канала + конфигурация
  - Доделать GroupChannelFactory
  - расширить параметры фабрики и канала параметрами групповых протоколов
  - перенести из тестовой фабрики из Flush тестов реализацию
* тесты
  - unit тесты
  - интеграционные и perf inprocess тесты
  - распределенное функциональное и perf тестирование на azure, включая механику имитации сбоев (используя tester)
* доп. сервисы (состав расширяемый)

Последовательно тестируем, что уже сделано и формируем канал на базе messaging для распределенного тестирования:
* тесты flush
* тесты state transfer + data exchange
* тесты atomic multicast
* тесты канала
