* исправить MulticastProtocolTests.testCoordinatorFailureAfterFlush
* подключить flow control к pending сообщениям мультикаста (receive и send)
* сделать PerfTest'ы мультикаста
  - посылает один, посылают все с максимальной скоростью
  - прямая посылка с учетом flowcontrol, pullable send
  - посылка больших, средних и маленьких сообщений
  - исследовать пропускную способность и задержки
  - исследовать влияние флаш, параметров фабрики, размера группы на задержки посылки на разных объемах состояния
* сборка проекта
* standalone test (простой и перфтест) разработать
---------------------
* продолжить тестирование остального
* Стратегия маппинга групп 
  - формирование групп с учетом старого маппинга и равномерного распределения новых групп и узлов, исключение выбывших
  - блокировка/разблокировка формирования членства группы в членстве кластера до момента завершения инсталляции ее локального членства через флаш
----------
* дописать дефалтовые значения в GroupChannelFactory
* Расширить StateTransfer Тесты - сделать тесты эмулирующие различные сбои при работе с состояние (reject, fail при загрузке/выгрузке и др.)
--------------------
Исследования на будущее:
* продумать изоляцию данных от кода, коллоцированных на одном хосте в одном (или разных узлах) с дешевым локальным взаимодействием между ними. Плюс - процессная изоляция, возможность использовать произвольную прикладную платформу (jvm, python, nodejs...)
* продумать про обновление кода - rolling updates, upfront поднятие доп. узла на том же хосте, спараллельным вводом его параллельно, без обновления данных (только код). Обновление частями кластера, например по зонам или по датацентрам
*  распределенный стриминг 
  - DAG обработка данных коллоцированная с самими данными, как узел графа - отдельный этап обработки
  - консистентные снимки, запись маркера в хранилище после определенного этапа обработки, с возможностью дальнейшего восстановления всего снимка для заданного маркера
  - использование окон данных для нарезки бесконечных потоков и обработка данных в рамках текущего окна
* дать возможность разделять на разных узлах узлы с данными и узлы без данных
* можно заменять имя потока на время выполнения запроса и восстанавливать после. Далее на проблемном запросе можно снять дамп потоков и увидеть всю диагностику. Аналогично можно использовать MDC или маркер для записи диагностики
---------------------------------
«Искусство войны» Сунь Цзы, «Самурае без меча» Масао Китами и «Книге пяти колец» Миямото Мусаси. 

Подробнее на РБК:
http://www.rbc.ru/opinions/business/14/03/2017/58c7cc329a79470adfcec757?utm_source=right_11
------------------
Standalone test:
* тестирующий протокол
  - в соответствии с заданным тестом формирует нагрузку и выполняет генерацию сбоев
* координирующий протокол
  - реализует проверки состояния, сбор статистики
-------------
* посылка сообщений
  - размер (малый, средний, большой, случайный, но не более заданного порога)
  - частота (заданная, на максимальной скорости, случайная)
  - тип (прямая посылка, pullable посылка, случайная)
  - источник (один узел, все узлы, случайный набор узлов, но не более заданного порога)
  - возможность комбинации вариантов
  - реализуется спец. протоколом, который принимает спецификацию тестирования, и реализует посылку, прием и применение сообщений на состоянии узла, 
* генерация сбоев
  - кто (простой узел, координатор, клиент переноса состояния, сервер переноса состояния, произвольный узел)
  - количество (один узел, заданное кол-во узлов, заданный процент от общего кол-ва, случайное кол-во, но не более заданного порога, все узлы)
  - когда (вне флаш, в заданной фазе флаш, в асинхронной фазе переноса состояния, в синхронной фазе, в случайное время, ...)
  - частота (заданная, при первом удобном случае, но не чаще заданного, случайная, но не более заданного порога)
  - возможность комбинации вариантов
* состояние
  - тип (простой, нормальный)
  - размер (малый, средний, большой, случайный, но не более заданного порога)

* реализация
  - имеем набор спецификаций тестирования (описанных выше)
  - имеем протокол тестирования, который по этим спецификациям реализует:
    - посылку сообщений
    - прием и применение сообщений над состоянием узла
    - регистрацию посылок, приемов и доставок и проверку их корректности
    - периодическую посылку, прием групповых сообщений снимков, по которым идет снятие снимков, состояний и отправка их на координатора с дальнейшей проверкой их идентичности
  - фабрики, создающей фабрику переноса состояния, которая на основе спецификаций тестирования сформирует нужные объекты переноса состояния, а также будет поддерживать состояние узла
  - протокола генерации сбоев, который в соотв. со спецификациями тестирования и перехватывая заданные события, будет генерировать сбои. Сбои реализуются через реконнектор канала, который закрывает канал в заданный мрмент времени и переподклбчается к группе через заданное время (определяемое спецификацией тестирования)
  - протокола статистики, реалищуется на базе протоколов интерсепторов, считает статистикуаналогично тому, как это было сделано ранее












